# FlashUnified

FlashUnified は、サーバーサイドとクライアントサイドの両方から利用できる統一的な Flash メッセージ描画の仕組みを Rails アプリに提供します。

サーバー側のビュー・ヘルパーで Flash メッセージをデータとしてページに埋め込み、クライアント側の軽量 JavaScript がそれを読み取ってページに表示します。

## 現在のステータス

バージョン v1.0.0 まではアルファ版として位置付けています。公開 API は安定しておらず、次のリリースで変更される可能性があります。

## モチベーション

同時に二つの課題がありました。

ひとつは、サーバーサイドからの Flash と同一の UI 表現で、クライアントサイドから発生するメッセージを表示できるようにしたいと思いました。たとえば巨大なリクエストがプロキシに遮断された時に、413 エラーを Flash として表示したい場合です。これはリクエストが Rails サーバーに到達しないため、クライアントサイドで処理する必要がありますが、その際に通常の Flash と同じ UI ロジックで表示したいのです。

そしてもうひとつに、Turbo Frame からも Flash メッセージを表示したいと思いました。フレーム内に Flash を表示するならば問題ないのですが、大抵の場合はフレームの外側で表示するようになっているでしょう。

## 仕組み

これらの課題を解決するポイントは、JavaScript 側で描画を行う必要があるという点です。そこでサーバー側とクライアント側で役割を分ける二段階の処理を考えました：

1. サーバーでは Flash オブジェクトをページ内に非表示の DOM 要素として埋め込み、ページを描画して返します。
2. クライアントの JavaScript はページの変化を検知したとき、その要素を走査し、埋め込まれたメッセージを読み取ってテンプレートで整形し、それを指定されたコンテナ要素に挿入（描画）します。またその際、重複表示を避けるためにメッセージ要素は DOM から取り除きます。

このように仕組みは単純で、その仕組を実装するためには、どのように埋め込みを行うかのルールを決めるだけです。この gem では次のように埋め込みの DOM 構造を定義し、「ストレージ」と呼ぶことにします：
```erb
<div data-flash-storage style="display: none;">
  <ul>
    <% flash.each do |type, message| %>
      <li data-type="<%= type %>"><%= message %></li>
    <% end %>
  </ul>
</div>
```

ストレージは非表示要素のため、サーバーが render するページのどこに置いても構いません。Turbo Frame の場合はフレームの中に置きます。

そして Flash メッセージを表示する場所である「コンテナ」、および整形のための「テンプレート」はストレージとは関係なく任意の場所に配置します。つまり Turbo Frame であっても、フレームの外側に配置されている Flash 描画領域に対して機能します。

フォームを送信した時にプロキシがエラーを返しくるようなケースをクライアントサイドで処理する場合は、 JavaScript から直接エラーメッセージを表示をするのではなく、メッセージをいったんストレージ要素として埋め込むことによって、同じように（同じテンプレート、同じ処理フローを用いて）Flash を描画することができるようになります。

一方で Flash をセットするコントーラでは、通常の Flashメッセージの表示の手続きとなんら変わるところがありません：
```ruby
if @user.save
  redirect_to @user, notice: "Created successfully."
else
  flash.now[:alert] = "Could not create."
  render :new, status: :unprocessable_content
end
```

つまりこの gem を導入するにあたって、**現在のコントローラは変更不要です**。また従来のページレイアウトも変える必要はほとんどありません。ビューに設定すべき DOM 要素は非表示要素であり、Flash メッセージを表示するコンテナ領域を少し調整するだけで済むでしょう。

この gem を導入することで主に実装すべきことは、埋め込みデータを Flash メッセージとして表示するタイミングです。通常はイベントを利用することになるでしょう。具体的な処理は実装者に委ねられますが、イベントのセットアップを自動で行うヘルパーも用意されています。任意の処理の中で、表示のためのメソッドを明示的に呼ぶこともできます。

## クイックスタート

### 1. インストール

Bundler を使用する場合は gem のエントリを Gemfile に追加し：
```
gem 'flash_unified'
```

コマンドを実行します：
```sh
$ bundle install
```

または直接インストールします：
```sh
$ gem install flash_unified
```

### 2. クライアントサイド設定（Importmap）

`config/importmap.rb` に追加します：
```ruby
pin "flash_unified/all", to: "flash_unified/all.bundle.js"
```

エントリポイントの JavaScript（例: `app/javascript/application.js`）で import します：
```js
import "flash_unified/all";
```

### 3. サーバーサイド設定

レイアウトの `<body>` 直後にヘルパーで "ソース" を配置します：
```erb
<body>
  <%= flash_unified_sources %>
  ...
```

メッセージを表示する位置にヘルパーで "コンテナ" を配置します：
```erb
<div class="notify">
  <%= flash_container %>
  ...
```

Turbo を使用する場合は、更新するコンテンツ内にストレージ要素を置く必要があります。

**Turbo Frame**

フレーム内にストレージ要素を置きます：
```erb
<turbo-frame id="foo">
  <%= flash_storage %>
```

**Turbo Stream**

ストリームでグローバル・ストレージ要素に対して、ストレージ要素を置くためのストリームを追加します：
```erb
<%= flash_turbo_stream %>
```

またはコントローラで済ませる場合：
```ruby
render turbo_stream: flash_turbo_stream
```

以上です。ページの変更を監視するイベントのハンドラーが、ストレージを走査してメッセージをコンテナに描画します。

## 詳細な使い方

カスタマイズ、API リファレンス、Turbo／ネットワークヘルパー、テンプレート、ロケール、ジェネレータの使用方法などは [`ADVANCED.ja.md`](ADVANCED.ja.md) を参照してください。 Sprockets などアセットパイプラインで使用する場合の例も示しています。

## 開発について

開発・テスト手順は [DEVELOPMENT.ja.md](DEVELOPMENT.ja.md) を参照してください。

## 変更履歴

変更履歴は [GitHub Releases page](https://github.com/hiroaki/flash-unified/releases) を参照してください。

## ライセンス

本プロジェクトは 0BSD (Zero-Clause BSD) ライセンスの下で公開されています。詳細は [LICENSE](LICENSE) をご確認ください。
